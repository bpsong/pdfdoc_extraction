## Relevant Files

- `tools/config_check/__main__.py` - Main entry point and CLI argument parsing
- `tools/config_check/validator.py` - Core validation logic and pass-based validation system
- `tools/config_check/schema.py` - Pydantic models for configuration schema validation
- `tools/config_check/path_validator.py` - Path existence and validation logic
- `tools/config_check/pipeline_validator.py` - Pipeline dependency and ordering validation
- `tools/config_check/reporter.py` - Output formatting and error reporting
- `tools/config_check/suggestions.py` - Suggestion engine for fixes and recommendations
- `tools/config_check/yaml_parser.py` - YAML parsing with location tracking
- `test/tools/config_check/` - Comprehensive test suite
- `tools/config_check/README.md` - Documentation and usage examples
- `tools/config_check/examples/` - Sample configuration files (valid_config.yaml, invalid_missing_paths.yaml)
- `pyproject.toml` - Modern Python packaging configuration with console script entry point
- `docs/config_check_troubleshooting.md` - Troubleshooting guide with common error scenarios and solutions

## Notes

- The tool should be implemented as a standalone CLI that can validate config.yaml files independently of the main application runtime
- Use the existing codebase patterns from [modules/config_manager.py](modules/config_manager.py) for path validation logic where applicable
- Implement a pass-based validation system where each validation concern is separated into distinct passes
- All validation errors should include file location information (line/column when available) for precise error reporting
- The tool should follow the same error handling patterns as the main application (critical logging and process exit)
- Consider using ruamel.yaml for better location tracking, with pyyaml as fallback
- Token extraction should handle both regular {token} patterns and escaped {{token}} patterns for secrets
- The CLI should be installable as a console script for easy usage in CI/CD pipelines

## Tasks

- [x] 1.0 Set up CLI tool project structure and dependencies
  - Acceptance: tools/config_check/ directory exists with __init__.py, requirements.txt lists all dependencies, __main__.py exists and is executable
  - Scaffold created under tools/config_check/ â€” files: [`__init__.py`](tools/config_check/__init__.py), [`__main__.py`](tools/config_check/__main__.py), [`validator.py`](tools/config_check/validator.py), [`schema.py`](tools/config_check/schema.py), [`path_validator.py`](tools/config_check/path_validator.py), [`README.md`](tools/config_check/README.md), [`requirements.txt`](tools/config_check/requirements.txt), [`setup_stub.py`](tools/config_check/setup_stub.py)
  - [x] 1.1 Create tools/config_check/ directory structure with __init__.py files
  - [x] 1.2 Set up requirements.txt with dependencies (pyyaml>=6.0, pydantic>=2.0, ruamel.yaml>=0.18)
  - [x] 1.3 Create __main__.py entry point with proper shebang and console script setup
  - [x] 1.4 Set up logging configuration matching main application patterns
  - [x] 1.5 Create basic setup.py for package installation and console script registration
- [x] 2.0 Implement CLI argument parsing and interface
  - [x] 2.1 Create ArgumentParser with validate and schema subcommands
  - [x] 2.2 Implement all required flags (--config, --format, --strict, --base-dir, --import-checks)
  - [x] 2.3 Add proper exit code handling (0=success, 1=errors, 2=warnings-only, 64=usage)
  - [x] 2.4 Add comprehensive help text and usage examples
  - [x] 2.5 Implement input validation for file paths and format options
- [x] 3.0 Implement YAML parsing with location tracking
  - [x] 3.1 Create YAML parser class that preserves location info using ruamel.yaml
  - [x] 3.2 Implement graceful fallback to pyyaml if ruamel.yaml unavailable
  - [x] 3.3 Handle YAML parsing errors with detailed file location reporting
  - [x] 3.4 Implement root validation (must be dictionary) with clear error messages
   - **Verified: YAMLParser tests pass on Windows; ruamel optional, PyYAML fallback confirmed.**
  - [x] 3.5 Add support for loading config from specified path or default locations
- [x] 4.0 Implement schema validation framework
  - [x] 4.1 Create Pydantic models for complete configuration schema
  - [x] 4.2 Implement pass-based validation system with separate validation passes
  - [x] 4.3 Add structural validation for required top-level keys and nested structure
  - [x] 4.4 Implement type validation for all configuration parameters
  - [x] 4.5 Add strict mode validation for unknown keys and properties
    - **Verified: Schema validation framework tests pass on Windows; 6/6 tests passed (valid config validation, missing required sections, pipeline string entries, unknown keys handling, strict mode, invalid on_error values). All Pydantic models and validation passes functioning correctly.**
- [x] 5.0 Implement path validation system
  - [x] 5.1 Create path validator that mirrors [modules/config_manager.py](modules/config_manager.py) logic
  - [x] 5.2 Implement base directory resolution for relative paths
  - [x] 5.3 Add special validation for watch_folder.dir (must exist, no auto-creation)
  - [x] 5.4 Create comprehensive path existence checking for *_dir and *_file patterns
  - [x] 5.5 Implement clear error messages with path suggestions and fixes
    - **Verified: Path validation system tests pass on Windows; 4/4 tests passed (existing paths acceptance, missing watch folder directory error reporting, missing dynamic directory error reporting, base directory resolution for relative paths). All path validation logic functioning correctly with Windows-safe handling.**
- [x] 6.0 Implement task existence and import validation
  - [x] 6.1 Create validator to ensure all pipeline tasks exist in tasks section
  - [x] 6.2 Implement optional import checking using importlib for module resolution
  - [x] 6.3 Add class existence validation within imported modules
  - [x] 6.4 Create meaningful error messages for import failures with troubleshooting suggestions
  - [x] 6.5 Handle cases where modules are not in PYTHONPATH with clear guidance
    - **Verified: Task validation system tests pass on Windows; 5/5 tests passed (task existence validation, import checking with importlib, class validation, error messages with suggestions, PYTHONPATH guidance). All task validation logic functioning correctly.**
- [x] 7.0 Implement pipeline dependency validation
  - [x] 7.1 Create token extraction logic for {token} patterns in parameter strings
  - [x] 7.2 Implement extraction-before-storage dependency rule validation
  - [x] 7.3 Implement nanoid-before-use dependency rule for {nanoid} tokens
  - [x] 7.4 Create unknown token detection and validation with field suggestions
  - [x] 7.5 Enforce at least one extraction task in pipeline
    - **Verified: Pipeline dependency validation system tests pass on Windows; 6/6 tests passed (token extraction logic for {token} patterns, extraction-before-storage dependency rule validation, nanoid-before-use dependency rule for {nanoid} tokens, unknown token detection and validation with field suggestions). All pipeline dependency validation logic functioning correctly.**
- [x] 8.0 Implement parameter-level validation
  - [x] 8.1 Create on_error value validation (must be 'stop' or 'continue')
  - [x] 8.2 Implement extraction field validation (alias, type, is_table properties)
  - [x] 8.3 Add storage task parameter validation (data_dir, filename patterns)
  - [x] 8.4 Implement archiver task parameter validation (archive_dir)
  - [x] 8.5 Create type validation for complex field definitions (List, Optional types)
  - [x] 8.6 Add validation for template token compatibility with available fields
    - **Verified: Parameter-level validation system tests pass on Windows; 7/7 tests passed (on_error value validation, extraction field validation, storage task parameter validation, archiver task parameter validation, type validation for complex field definitions, template token compatibility validation). All parameter-level validation logic functioning correctly.**
- [x] 9.0 Implement output formatting and reporting
  - [x] 9.1 Create Finding class for structured error/warning reporting
  - [x] 9.2 Implement text format output with proper grouping and formatting
  - [x] 9.3 Implement JSON format output for machine-readable results
  - [x] 9.4 Add finding categorization system (ERROR, WARNING, INFO levels)
  - [x] 9.5 Create summary statistics and proper exit code determination
  - [x] 9.6 Ensure all findings include config path and actionable suggestions
- [x] 10.0 Implement suggestions engine
  - [x] 10.1 Create suggestion template system for common validation issues
  - [x] 10.2 Implement path-related suggestions (directory creation, config updates)
  - [x] 10.3 Add task-related suggestions (missing task definitions, pipeline reordering)
  - [x] 10.4 Implement token-related suggestions (field additions, template fixes)
  - [x] 10.5 Create dependency-related suggestions (task movement, prerequisite addition)
  - [x] 10.6 Ensure all suggestions are actionable and copy-paste friendly
- [x] 11.0 Create comprehensive test suite
  - [x] 11.1 Set up pytest configuration with fixtures for test configurations
  - [x] 11.2 Create unit tests for each validation pass and component
  - [x] 11.3 Add integration tests with valid and invalid sample config files
  - [x] 11.4 Create CLI interface tests with different flag combinations
  - [x] 11.5 Add output format tests for both text and JSON formats
  - [x] 11.6 Implement edge case tests for malformed YAML, missing files, import errors
  - [x] 11.7 Create performance tests to ensure sub-300ms validation time
- [x] 12.0 Create documentation and packaging
  - [x] 12.1 Write comprehensive README with installation and usage instructions
  - [x] 12.2 Create sample configuration files (valid and invalid) for testing
  - [x] 12.3 Add pyproject.toml for modern Python packaging
  - [x] 12.4 Write troubleshooting guide with common error scenarios and solutions
  - [x] 12.5 Add inline documentation and docstrings throughout codebase


